!function(n){function e(s){if(r[s])return r[s].exports;var a=r[s]={i:s,l:!1,exports:{}};return n[s].call(a.exports,a,a.exports,e),a.l=!0,a.exports}var r={};e.m=n,e.c=r,e.d=function(n,r,s){e.o(n,r)||Object.defineProperty(n,r,{configurable:!1,enumerable:!0,get:s})},e.n=function(n){var r=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(r,"a",r),r},e.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},e.p="",e(e.s=0)}([function(module,exports,__webpack_require__){eval("\r\nvar frameRpc = __webpack_require__(1)\r\n\r\nwindow.frameRpc = frameRpc;\r\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/export.js\n// module id = 0\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/export.js?")},function(module,exports,__webpack_require__){eval('\r\nconst cuid = __webpack_require__(2)\r\nconst msgPrefix = "rpc_"\r\nconst debug = function() {\r\n  return window.frameRpcConfig && window.frameRpcConfig.debug == true ? true : false;\r\n}\r\n\r\nconst msgtype = {\r\n\r\n  // 消息回调通知\r\n  // 实现异步调用返回\r\n  sys_event_callback_msg_send : "sys_event_callback_msg_send",\r\n\r\n  // 消息转发\r\n  // iframe是无法直接与另一个iframe通信的，因为top可能与本iframe不同域\r\n  // 这种类型是为top增加一个转发动作，由top转发两个iframe之间的通信\r\n  // 也可以作为iframe转发给他的子iframe\r\n  sys_action_message_forward : "sys_action_message_forward"\r\n\r\n}\r\n\r\n// 通过iframe的name属性，获取iframe\r\nconst loadFrameByName = function(frameName) {\r\n    var frameArray = [].slice.call(document.getElementsByTagName("iframe")).filter(function(item,index) {return item.name == frameName});\r\n    if (frameArray && frameArray.length > 0) {\r\n        return frameArray[0]\r\n    }\r\n}\r\n\r\n\r\nconst listener = function(type, fn) {\r\n    if (!type || !fn) {\r\n        throw "listener error parmar, type and fn is required"\r\n    }\r\n    if (debug()) {\r\n      console.log("[tofun] [message] add listener", type, window.location.href)\r\n    }\r\n    window.addEventListener(\'message\', function (e) {\r\n        if (!e.data || !e.data.indexOf || e.data.indexOf(msgPrefix) != 0) {\r\n            return;\r\n        }\r\n        var message = JSON.parse(e.data.substring(msgPrefix.length, e.data.length));\r\n        if (debug()) {\r\n          console.log("[message] recv message", message, type, message.msgSrcFrameName + " -> " + window.location.href)\r\n        }\r\n        if (message.type == type) {\r\n            // 调用已经注册的方法\r\n            var promise = fn(message, e);\r\n            // 回调\r\n            if (message.type != msgtype.sys_event_callback_msg_send\r\n                    && message.msgSrcFrameName && message.msgSrcFrameName.length > 0) {\r\n                // 获取来源对象\r\n                // 因为postMessage机制的限制，无法使用事件获取来源对象\r\n                var messageSrcWindow;       // 消息发送来源\r\n                if (loadFrameByName(message.msgSrcFrameName)) {\r\n                    messageSrcWindow = loadFrameByName(message.msgSrcFrameName).contentWindow;\r\n                } else {\r\n                    messageSrcWindow = top.window;\r\n                }\r\n                // 通知\r\n                if (promise && promise.then) {\r\n                    // 异步模式，使用promise回调\r\n                    promise.then(function(parmar) {\r\n                        sender({\r\n                            type : msgtype.sys_event_callback_msg_send,\r\n                            srcMsgId : message.msgId,\r\n                            parmar : promise ? JSON.stringify(parmar) : undefined\r\n                        }, messageSrcWindow)\r\n                    })\r\n                } else {\r\n                    // 同步模式\r\n                    sender({\r\n                        type : msgtype.sys_event_callback_msg_send,\r\n                        srcMsgId : message.msgId,\r\n                        parmar : promise ? JSON.stringify(promise) : undefined\r\n                    }, messageSrcWindow)\r\n                }\r\n            }\r\n        }\r\n    }, false, 100)\r\n}\r\n\r\n\r\n// 消息发送回调注册，msgId : fn\r\nconst senderCallbackMap = {}\r\n\r\nconst sender = function(message, target) {\r\n    // 参数容错\r\n    if (!message) {\r\n        message = {};\r\n    }\r\n    if (!message.type) {\r\n      throw "error parmar, message.type is required"\r\n    }\r\n    if (!target || !target.postMessage) {\r\n        target = window.top;\r\n    }\r\n    if (!message.msgId || message.msgId.length <= 0) {\r\n        message.msgId = cuid();\r\n    }\r\n    if (window === top.window) {\r\n        message.msgSrcFrameName = \'top\'\r\n    } else if (window.name && window.name.length > 0) {\r\n        message.msgSrcFrameName = window.name;\r\n    } else {\r\n        console.warn("unable get window.name, promise callback is not support!")\r\n    }\r\n    //\r\n    if (debug()) {\r\n      console.log("send message", message, window.location.href)\r\n    }\r\n    var stringMessage;\r\n    try {\r\n      stringMessage = msgPrefix + JSON.stringify(message);\r\n    } catch (e) {\r\n      throw "In the process of sending the message, JSON.stringify faild, maybe message objects are not serializable.";\r\n    }\r\n    target.postMessage(stringMessage, "*")\r\n    // 注册回调\r\n    return new Promise(function(resolve, reject) {\r\n        senderCallbackMap[message.msgId] = resolve;\r\n    })\r\n}\r\n\r\n\r\nlistener(msgtype.sys_event_callback_msg_send, function (msg) {\r\n    if (msg && msg.srcMsgId && senderCallbackMap[msg.srcMsgId]) {\r\n        //\r\n        var parmar = msg.parmar ? JSON.parse(msg.parmar) : undefined;\r\n        //\r\n        senderCallbackMap[msg.srcMsgId](parmar);\r\n        delete senderCallbackMap[msg.srcMsgId];\r\n    }\r\n})\r\n\r\n\r\nmodule.exports = {\r\n  listener : listener,\r\n  sender : sender\r\n}\r\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 1\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/index.js?')},function(module,exports,__webpack_require__){eval("/**\n * cuid.js\n * Collision-resistant UID generator for browsers and node.\n * Sequential for fast db lookups and recency sorting.\n * Safe for element IDs and server-side lookups.\n *\n * Extracted from CLCTR\n *\n * Copyright (c) Eric Elliott 2012\n * MIT License\n */\n\n/*global window, navigator, document, require, process, module */\n(function (app) {\n  'use strict';\n  var namespace = 'cuid',\n    c = 0,\n    blockSize = 4,\n    base = 36,\n    discreteValues = Math.pow(base, blockSize),\n\n    pad = function pad(num, size) {\n      var s = \"000000000\" + num;\n      return s.substr(s.length-size);\n    },\n\n    randomBlock = function randomBlock() {\n      return pad((Math.random() *\n            discreteValues << 0)\n            .toString(base), blockSize);\n    },\n\n    safeCounter = function () {\n      c = (c < discreteValues) ? c : 0;\n      c++; // this is not subliminal\n      return c - 1;\n    },\n\n    api = function cuid() {\n      // Starting with a lowercase letter makes\n      // it HTML element ID friendly.\n      var letter = 'c', // hard-coded allows for sequential access\n\n        // timestamp\n        // warning: this exposes the exact date and time\n        // that the uid was created.\n        timestamp = (new Date().getTime()).toString(base),\n\n        // Prevent same-machine collisions.\n        counter,\n\n        // A few chars to generate distinct ids for different\n        // clients (so different computers are far less\n        // likely to generate the same id)\n        fingerprint = api.fingerprint(),\n\n        // Grab some more chars from Math.random()\n        random = randomBlock() + randomBlock();\n\n        counter = pad(safeCounter().toString(base), blockSize);\n\n      return  (letter + timestamp + counter + fingerprint + random);\n    };\n\n  api.slug = function slug() {\n    var date = new Date().getTime().toString(36),\n      counter,\n      print = api.fingerprint().slice(0,1) +\n        api.fingerprint().slice(-1),\n      random = randomBlock().slice(-2);\n\n      counter = safeCounter().toString(36).slice(-4);\n\n    return date.slice(-2) +\n      counter + print + random;\n  };\n\n  api.globalCount = function globalCount() {\n    // We want to cache the results of this\n    var cache = (function calc() {\n        var i,\n          count = 0;\n\n        for (i in window) {\n          count++;\n        }\n\n        return count;\n      }());\n\n    api.globalCount = function () { return cache; };\n    return cache;\n  };\n\n  api.fingerprint = function browserPrint() {\n    return pad((navigator.mimeTypes.length +\n      navigator.userAgent.length).toString(36) +\n      api.globalCount().toString(36), 4);\n  };\n\n  // don't change anything from here down.\n  if (app.register) {\n    app.register(namespace, api);\n  } else if (true) {\n    module.exports = api;\n  } else {\n    app[namespace] = api;\n  }\n\n}(this.applitude || this));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/cuid/dist/browser-cuid.js\n// module id = 2\n// module chunks = 0\n\n//# sourceURL=webpack:///./node_modules/cuid/dist/browser-cuid.js?")}]);